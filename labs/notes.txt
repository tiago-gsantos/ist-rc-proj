int gethostname(char *name, size_t len); -> This system call is used to access the system's hostname.


int getaddrinfo(const char *node,             -> internet hostname or internet address
                const char *service,          -> internet service / port number
                const struct addrinfo *hints, -> pointer to addrinfo structure that specifies criteria for selecting the socket address structures returned in the ...
                struct addrinfo **res);       -> ... list pointed to by res
if hostname NULL and hints->ai_flags = AI_PASSIVE returns addr suitable for binding socket to accept incoming connections


127.0.1.1 -> loopback address - refering to itself


int socket(int domain,    -> the protocol family (AF_INET for IPv4)
           int type,      -> the communication semantics (SOCK_DGRAM for datagram-UDP and SOCK_STREAM for TCP)
           int protocol);  when == 0, it chooses automaticaly the best protocol for the given domain and type
-> creates socket and returns it's file descriptor.


ssize_t sendto(int sockfd,                       -> fd of the sending socket
               const void *buf,                   -> message
               size_t len, 
               int flags,
               const struct sockaddr *dest_addr, -> ignored when in connection-mode (SOCK_STREAM)
               socklen_t addrlen);               -> ignored when in connection-mode (SOCK_STREAM)


ssize_t recvfrom(int sockfd,
                 void *buf,
                 size_t len,
                 int flags,
                 struct sockaddr *src_addr, -> if not NULL, the source address is placed here
                 socklen_t *addrlen);
-> return length of message on successful completion. waits for message and returns once it gets some data, not necessarily the full message 


int getnameinfo(const struct sockaddr *addr,
                socklen_t addrlen,
                char *host,
                socklen_t hostlen,
                char *serv,
                socklen_t servlen,
                int flags);
-> inverse of getaddrinfo - converts address into host and service


int connect(int sockfd,
            const struct sockaddr *addr,
            socklen_t addrlen);
-> connects to the reffered socket (sockfd) to the address specified by addr


read() / write() for TCP and recvfrom() / sendto() for UDP ??

If the connection is lost and we write to the socket, the system will raise a SIGPIPE signal and, by default, this will kill the process. To prevent this use sigaction to ignore SIGPIPE signal


int bind(int sockfd, 
         const struct sockaddr *addr,
         socklen_t addrlen);
-> When  a  socket is created with socket(), it exists in a name space (address family) but has no address assigned to it.  bind() assigns the address specified by addr to the socket referred to by the file descriptor sockfd


int listen(int sockfd,
           int backlog); -> maximum length to which the queue of pending connections may grow
-> marks socket as passive socket - socket that will be used to accept incoming connection requests using accept()


int accept(int sockfd,
           struct sockaddr *addr, -> address of the connected peer process
           socklen_t *addrlen);
-> extracts the first connection request on the queue of pending connections, creates a new connected socket, and returns a new fd referring to that socket


int select(int nfds,
           fd_set *readfds,     -> these 3 args are "sets" of fd, meaning that the caller can specify which of the 3 classes of event do the fd belong to. 
           fd_set *writefds,    -> ...
           fd_set *exceptfds,   -> ...
           struct timeval *timeout);
-> allows a program to monitor multiple fd's, waiting until one or more of the fd's become "ready" for some I/O operation

The contents of a file descriptor set can be manipulated using the following macros:
  
  void FD_ZERO(fd_set *set);
  -> This macro removes all fd's from set. It should be employed as the first step in initializing a fd set.
  void FD_SET(int fd, fd_set *set);
  -> This macro adds the fd to set.
  void FD_CLR(int fd, fd_set *set);
  -> This macro removes the fd from set.
  int  FD_ISSET(int fd, fd_set *set);
  -> after calling select(), this macro can be used to test if a fd is still present in a set (since after select returns, it modifies the sets to indicate which fd are currently ready), returning nonzero if it is










socket -> communication endpoint that allows data to be sent and received over a network (infrastructure) - interface between an application and the underlying network protocols;
          uses IP address and port numbers;
          Steps to Use Sockets:
            - Create a Socket: The application creates a socket to initiate communication.
            - Bind the Socket (Server Only): The server binds the socket to a specific IP address and port to listen for incoming connections.
            - Listen for Connections (Server Only): The server listens for connection requests from clients.
            - Connect to the Server (Client Only): The client connects to the server via the server's IP address and port number.
            - Send and Receive Data: Once the connection is established, data can be sent and received through the socket.
            - Close the Socket: After communication is complete, the socket is closed to free up resources.
datagram -> packets of data used in UDP (TCP uses stream)
